Demo Links
Public API: [<PUBLIC_URL>](https://order-engine-api.onrender.com/)
Swagger UI: [<PUBLIC_URL>/docs](https://order-engine-api.onrender.com/docs)
Short demo video: [<YOUTUBE_LINK>](https://youtu.be/PNiqlbGMQ1I)
Doc: [<DOC_LINK>](https://docs.google.com/document/d/1M30rdY4gvSosTn18aADyT_0FDge5vnVsPWPw42RZKeg/edit?usp=sharing)
Postman file: postman_collection.json (in repo)

# Order Execution Engine

the repo itself houses the tiny order execution sandbox. Drop in an order, stream every lifecycle update over WebSocket, then read the canonical record from Postgres once the worker wraps up.

## TL;DR
- Fastify API with Swagger, request validation, 120 req/min rate limit, and idempotent POST `/api/orders/execute`.
- BullMQ worker compares Raydium vs Meteora quotes, applies slippage guards, and persists each state change.
- Redis backs the queue, gates (rate + idempotency), and pub/sub so WebSockets feel real-time.
- Prisma models keep Postgres honest; tests focus on the worker + math helpers.
- Tooling: Postman + Insomnia collections, CLI WS client, short Loom-style demo.

## Shape of the system
```
[client] --HTTP--> Fastify API --enqueue--> BullMQ (Redis)
    |                      |                 |
    |                      v                 v
    |                Prisma/Postgres    Worker + MockDexRouter
    |                      ^                 |
    '--- WebSocket <-------'-- Redis pub/sub |
```
- API thread just validates, records the order, enqueues the job, and streams `pending` right away.
- Worker picks the healthier route, simulates execution, and either confirms or fails (slippage, etc.).
- Redis pub/sub mirrors every event, so late WS subscribers get a replay plus anything new.

## Try the API

**1. Create an order**
```bash
curl -X POST <PUBLIC_URL>/api/orders/execute \
  -H "Content-Type: application/json" \
  -H "x-idempotency-key: demo-run-123" \
  -d '{"orderType":"market","tokenIn":"SOL","tokenOut":"USDC","amount":1.5}'
```
Returns `{ "orderId": "...", "idempotent": false }`; resubmitting with the same idempotency key simply replays prior events.

**2. Stream updates**
- `ws://<PUBLIC_URL>/api/orders/execute?orderId=<id>` pushes the full lifecycle (`pending → routing → building → submitted → confirmed/failed`).
- Local helper: `npm run ws -- <orderId>`.

**3. Grab the snapshot**
```bash
curl <PUBLIC_URL>/api/orders/<orderId>
```
You’ll get the order row plus every persisted event. Bonus endpoints: `GET /health` for uptime checks, `GET /docs` for Swagger.

## Local dev
- **Prereqs**: Node 20+, npm, Docker (or local Postgres + Redis), `.env` from `.env.example`.
- **Boot flow**:
  1. `cp .env.example .env`
  2. `docker compose up -d`
  3. `npm install`
  4. `npx prisma migrate deploy`
  5. `npm run dev:api` and `npm run dev:worker` in separate tabs (or `npm run dev:watch` for auto-restarts)

Prod-style run:
```bash
npm run build
npm run start:api &
npm run start:worker
```
Shell helpers `start-api.sh` / `start-worker.sh` wrap the same commands.

## Scripts
- `npm test` – Jest for the worker + helpers.
- `npm run ws -- <orderId>` – quick WebSocket tail.
- `npm run prisma:generate` – refresh Prisma client after schema tweaks.

## Collections & demo aids
1. Import **postman_collection.json** and hit **Create Market Order**; the Tests tab captures `orderId` into your environment.
2. For streaming, either use **insomnia_collection.json** (POST, copy `orderId`, start the WS request) or the CLI helper.
3. Want the final record without WS? `GET /api/orders/{orderId}` straight from Swagger does the trick.

## Environment knobs
- `PORT` – Fastify port.
- `DATABASE_URL` – Postgres DSN for Prisma.
- `REDIS_URL` – shared Redis endpoint (queue, pub/sub, rate, idempotency).
- `DEFAULT_SLIPPAGE_BPS` – fallback tolerance (50 bps default).
- `API_MAX_ORDERS_PER_MIN` / `QUEUE_MAX_PER_MIN` – backpressure controls.

## Design notes
- Async API/worker split keeps POST latency tiny while BullMQ absorbs the heavy lifting.
- Every status change emits to Redis pub/sub (for WS) and lands in Postgres (for later audits + replay).
- Redis also acts as our safety net for rate limiting, idempotency, and exponential backoff.
- MockDexRouter isolates the quote/execution surface so you can plug real Solana routes later without touching the worker contract.
- Prisma schema mirrors production expectations with `Order` / `OrderEvent`, cascading deletes, and server timestamps.

Need another environment or more detail? Ping me and we’ll riff.
